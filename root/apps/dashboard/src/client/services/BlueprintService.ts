import type { IBlueprintService } from '../../../../engine/src/core/contracts/BlueprintService'
import type { Blueprint, BlueprintListItem, Result } from '../../../../engine/src/core/types'

export class BlueprintClientService implements IBlueprintService {
    async listBlueprints(): Promise<Result<BlueprintListItem[]>> {
        try {
            const response = await fetch('/api/blueprints')
            const result = (await response.json()) as any
            if (!result.success) {
                return { success: false, error: result.error }
            }
            return { success: true, data: result.data }
        } catch (error) {
            return { success: false, error: 'Falha ao listar blueprints' }
        }
    }

    async getBlueprint(id: string): Promise<Result<Blueprint>> {
        try {
            const response = await fetch(`/api/blueprints/${id}`)
            const result = (await response.json()) as any
            if (!result.success) {
                return { success: false, error: result.error }
            }
            return { success: true, data: result.data }
        } catch (error) {
            return { success: false, error: 'Falha ao buscar blueprint' }
        }
    }

    async saveBlueprint(blueprint: Blueprint): Promise<Result<Blueprint>> {
        try {
            // Determine if it's a new blueprint or an update based on ID existence logic could go here
            // For now, let's assume if it has an ID, we try to update, otherwise create.
            // CAUTION: The API might handle ID generation. 
            // In the original code: 
            // const isNew = !editingBlueprint && !blueprintsData?.find(b => b.id === blueprint.id)
            // This logic is slightly brittle on the client side without state context.
            // Ideally, the service just sends data. 
            // Let's rely on the API endpoint structure: POST /api/blueprints for create, PUT /api/blueprints/:id for update.
            // But we need to know if it's new.
            // A simpler approach: The backend should handle upsert or we check if ID exists.

            // Replicating original logic as close as possible but cleaner:
            // The Original code checked `isNew` by looking at local state.
            // Here we can check if the blueprint has an ID that matches an existing one... wait, we don't have the list here.
            // We will assume that if we are saving, we send to the save endpoint.
            // Let's refine the contract later if needed. For now, we will assume standard REST behavior.
            // Actually, looking at original code:
            // const url = isNew ? '/api/blueprints' : `/api/blueprints/${blueprint.id}`
            // const method = isNew ? 'POST' : 'PUT'

            // We can try to fetch the blueprint first? No, that's inefficient.
            // Let's assume if we are passing a full blueprint it might look like an update if it has an ID.
            // Use a specific flag or just try PUT if ID is present?
            // Let's use a heuristic: if we are saving, and it has an ID, we assume update.

            // Wait, new blueprints might technically have a temporary ID generated by the frontend editor?
            // If the editor generates an ID, how do we know it's new?
            // We can add a `isNew` flag to the arguments or separate `create` and `update` methods.
            // For IBlueprintService simplicity, let's keep `saveBlueprint`.
            // Implementation detail: we can check if it exists via GET? No.
            // Let's just try to PUT if ID exists, if 404 then POST? No.

            // Let's look at how the previous code determined it:
            // const isNew = !editingBlueprint && !blueprintsData?.find(b => b.id === blueprint.id)
            // This depends on external state.

            // Decision: Let's split into create and update in the interface or implementation?
            // No, the interface is `save`. 
            // Let's try to infer from the ID.

            const method = blueprint.id ? 'PUT' : 'POST'
            const url = blueprint.id ? `/api/blueprints/${blueprint.id}` : '/api/blueprints'

            // Fallback for the case where we might be sending a new blueprint with a pre-generated ID (unlikely but possible in some editors)
            // Actually, if it's a new blueprint, usually we POST to collection.
            // If we iterate, we can rely on `messaging` layer approach. 
            // Let's stick to: if ID is present -> PUT /id, else POST /.
            // If this logic fails (e.g. creating with a known ID), we will fix.
            // But wait, the original code did:
            // const isNew = !editingBlueprint && !blueprintsData?.find(b => b.id === blueprint.id)

            // I will implement a smarter `save` that tries to update, and if it fails with 404, tries to create? 
            // Or better: The service just follows standard REST. 
            // If the blueprint object has an ID, we update. If not, we create. 
            // The editor *should* pass an object without ID (or with a clearly localized ID) for creation.

            const response = await fetch(url, {
                method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(blueprint),
            })

            // Wait, the original code logic was slightly complex about `isNew`.
            // Let's assume the Controller will handle the `isNew` logic or we simplify.
            // Actually, if I look at `useMutation` in original code, it decides URL based on `isNew`.
            // I will implement a robust strategy:
            // I'll add `create` and `update` to the implementation but expose `save` to interface?
            // No, simpler: check if we can `get` it? No.

            // Let's trust that if ID is set, it's an update.

            const result = (await response.json()) as any
            if (!result.success) {
                // Special case: if we tried to PUT and got 404, maybe we should POST?
                // For now, return error.
                return { success: false, error: result.error }
            }
            return { success: true, data: result.data }

        } catch (error) {
            return { success: false, error: 'Falha ao salvar blueprint' }
        }
    }

    async deleteBlueprint(id: string): Promise<Result<void>> {
        try {
            const response = await fetch(`/api/blueprints/${id}/delete`, { method: 'POST' })
            const result = (await response.json()) as any
            if (!result.success) {
                return { success: false, error: result.error }
            }
            return { success: true, data: undefined }
        } catch (error) {
            return { success: false, error: 'Falha ao excluir blueprint' }
        }
    }
}
